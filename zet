#!/bin/bash

set -o errexit

EDITOR="${EDITOR:-vi}"
ZET_DIR="${ZET_DIR:-$HOME/zet}"
BUFF_DIR="$ZET_DIR/buffer"


__git() { git -C "$ZET_DIR" "$@" ; }

__is_initialized() {
    [ -d "$ZET_DIR" ]
    return $?
}

__check_init() {
    if ! __is_initialized; then
        echo "Zettelkasten repository has not been initiated. Run 'zet init' to do so."
        exit 1
    fi
}

__check_remote() {
    local remote="${1:-origin}"
    if ! __git remote show "$remote" &> /dev/null; then
        echo "Remote '$remote' is not properly configured."
        echo "Run 'zet remote add \"$remote\" <URL>' to configure it."
        exit 1
    fi
}

__assure_dir() {
    if [ ! -d "$1" ]; then
        echo "Creating '$1' directory."
        mkdir -p "$1"
    fi
}

__buffers() {
    find "$BUFF_DIR" -type f -name "*.md" -printf "%f\n" \
        | sed -nE "s:(.*).md$:\1:pg"
}

__assure_zet_exists() {
    if [ ! -e "$ZET_DIR/$1/README.md" ]; then
        echo "Zettel with id '$1' does not exist."
        exit 1
    fi
}

__zet_dir() { echo "$ZET_DIR/$1" ; }
__zet_file() { echo "$(__zet_dir "$1")/README.md" ; }

__zet_title() { sed -nE "s:^\s*#\s*(.*).*$:\1:p" < "$(__zet_file "$1")" ; }

__zet_info() {
    local zet_id="$1"
    __assure_zet_exists "$zet_id"

    cat <<EOF
ID: $zet_id
File: $(__zet_file "$zet_id")
Title: "$(__zet_title "$zet_id")"
Tags: TODO: implement it
EOF
}

x.init() {
    if __is_initialized; then
        echo "Zettelkasten already initialized. ($ZET_DIR)"
    else
        mkdir -p "$ZET_DIR"
        __git init
        echo "Configure a default remote with 'zet remote add origin <URL>'."
    fi
}

x.new() {
    __check_init

    local zet_id="$(date +"%Y%m%d%H%M%S%3N")"
    local zet_file="$(__zet_file "$zet_id")"

    mkdir -p "$(__zet_folder "$zet_id")"
    touch "$zet_file"
    echo "---" >> "$zet_file"
    echo "id: $zet_id" >> "$zet_file"
    echo "tags: []" >> "$zet_file"
    echo "---" >> "$zet_file"

    exec "$EDITOR" "$zet_file"
}

x.buff() {
    __check_init
    __assure_dir "$BUFF_DIR"

    local buff=""
    while getopts "ls" opt; do
        case "$opt" in
        l) __buffers ; exit 0 ;;
        s) buff="$(__buffers | fzf)" ;;
        esac
    done
    buff="${buff:-${1:-inbox}}"

    if [ -z "$buff" ]; then
        echo "A buffer should be specified."
        exit 1
    fi

    # TODO: why the error logging when editor quits without saving?
    exec "$EDITOR" "$BUFF_DIR/$buff.md" 2> /dev/null
}

x.tags() {
    # TODO: cache for tag research? files with indexes for each tag that can be
    # used for searching, or refreshed.
    __check_init
}

x.search() {
    __check_init
}

x.remote() {
    __check_init
    __git remote "$@"
}

x.sync() {
    __check_init
    local remote="${1:-origin}"
    __check_remote "$remote"

    # TODO: when conflicts happen, should a prompt for resolution be opened?
    __git pull --prune
    __git status --short
    __git add --all
    __git commit --verbose
    __git push -u "$remote"
}

x.list() {
    __check_init
    find "$ZET_DIR" -type d -regex "$ZET_DIR/[0-9]+" -printf "%f\n" \
    | while read zet_id; do
        echo "$zet_id $(__zet_title "$zet_id")"
    done
}

x.info() {
    __check_init
    __zet_info "$1"
}

x.install() {
    local target_dir="/usr/local/bin"
    local ln_install=false
    while getopts "sd:" opt; do
        case "$opt" in
            d) target_dir="$OPTARG" ;;
            s) ln_install=true ;;
        esac
    done

    if [ $ln_install ]; then
        echo "Installing with symbolic link."
        ln -fs "$(realpath "$0")" "$target_dir/zet"
        exit 0
    else
        cp "$0" "$target_dir"
    fi
}

case "$1" in
    new)     shift ; x.new     "$@" ;;
    init)    shift ; x.init    "$@" ;;
    sync)    shift ; x.sync    "$@" ;;
    remote)  shift ; x.remote  "$@" ;;
    buff)    shift ; x.buff    "$@" ;;
    install) shift ; x.install "$@" ;;
    list)    shift ; x.list    "$@" ;;
    info)    shift ; x.info    "$@" ;;
    *) echo "Unknown command '$1'" ; exit 1 ;;
esac
